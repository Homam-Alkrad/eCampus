<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP in C#</title>
    <link rel="stylesheet" href="styles.css">
    <style>
ul {
    list-style-type: disc;         /* Bullet type */
    padding-left: 20px;            /* Indent */
    margin: 10px 0;                /* Vertical spacing */
    font-family: Arial, sans-serif;
    font-size: 16px;
    color: #333;
}

ul li {
    padding: 6px 0;                /* Space between items */
    transition: background-color 0.3s;
}

ul li:hover {
    background-color: #f0f0f0;     /* Light hover effect */
    cursor: pointer;
}
</style>

</head>

<body>
<!-- LinkedList Data Structure -->
<section id="linkedlist" class="section">
    <h2>LinkedList in C++</h2>
    <div class="definition">
        <p class="english-def"><strong>Definition:</strong> A <span class="keyword">LinkedList</span> is a linear data structure where elements are stored in nodes, with each node containing data and a reference to the next node.</p>
        <p class="arabic-def"><strong>التعريف:</strong> <span class="keyword">القائمة المتصلة</span> هي هيكل بيانات خطي حيث يتم تخزين العناصر في عقد، وكل عقدة تحتوي على بيانات وإشارة إلى العقدة التالية.</p>
    </div>

    <div class="explanation">
        <p>LinkedLists provide dynamic storage that can grow or shrink at runtime. Unlike arrays, elements aren't stored in contiguous memory locations, making insertions and deletions efficient at any position.</p>
    </div>

    <h3>Example 1: Basic Node Structure</h3>
    <pre class="code-block"><code><span class="code-keyword">class</span> Node {
<span class="code-keyword">public</span>:
    <span class="code-keyword">int</span> data;     <span class="code-comment">// Data stored in the node</span>
    Node* next;    <span class="code-comment">// Pointer to the next node</span>
    
    <span class="code-comment">// Constructor</span>
    Node(<span class="code-keyword">int</span> value) {
        data = value;
        next = nullptr;  <span class="code-comment">// Initially, the next pointer is null</span>
    }
};</code></pre>
    <div class="explanation">
        <p>The <code>Node</code> class is the building block of a LinkedList. Each node contains:</p>
        <ul>
            <li><strong>data</strong>: The value stored in the node (an integer in this example)</li>
            <li><strong>next</strong>: A pointer to the next node in the list</li>
        </ul>
        <p>When a node is created, its <code>next</code> pointer is initialized to <code>nullptr</code>, indicating it doesn't point to any other node yet.</p>
    </div>

    <h3>Example 2: LinkedList Class</h3>
    <pre class="code-block"><code><span class="code-keyword">class</span> LinkedList {
<span class="code-keyword">private</span>:
    Node* head;  <span class="code-comment">// Pointer to the first node in the list</span>
    
<span class="code-keyword">public</span>:
    <span class="code-comment">// Constructor</span>
    LinkedList() {
        head = nullptr;  <span class="code-comment">// Empty list has no nodes</span>
    }
    
    <span class="code-comment">// Other methods will be added later</span>
};</code></pre>
    <div class="explanation">
        <p>The <code>LinkedList</code> class maintains a pointer to the first node (the <code>head</code>) of the list. In an empty list, <code>head</code> is <code>nullptr</code>.</p>
    </div>

    <h3>Example 3: Creating and Connecting Nodes Manually</h3>
    <pre class="code-block"><code><span class="code-keyword">int</span> main() {
    <span class="code-comment">// Create individual nodes</span>
    Node* node1 = <span class="code-keyword">new</span> Node(10);
    Node* node2 = <span class="code-keyword">new</span> Node(20);
    Node* node3 = <span class="code-keyword">new</span> Node(30);
    
    <span class="code-comment">// Connect the nodes to form a linked list</span>
    node1->next = node2;  <span class="code-comment">// 10 -> 20</span>
    node2->next = node3;  <span class="code-comment">// 10 -> 20 -> 30</span>
    
    <span class="code-comment">// Now node1 is the head of our linked list</span>
    Node* head = node1;
    
    <span class="code-comment">// Traversing and printing the list</span>
    Node* current = head;
    <span class="code-keyword">while</span> (current != nullptr) {
        cout << current->data << " ";  <span class="code-comment">// Output: 10 20 30</span>
        current = current->next;
    }
    
    <span class="code-comment">// Don't forget to free the memory</span>
    <span class="code-keyword">delete</span> node1;
    <span class="code-keyword">delete</span> node2;
    <span class="code-keyword">delete</span> node3;
    
    <span class="code-keyword">return</span> 0;
}</code></pre>
    <div class="explanation">
        <p>This example demonstrates how to:</p>
        <ul>
            <li>Create individual nodes with different values</li>
            <li>Connect nodes by setting their <code>next</code> pointers</li>
            <li>Traverse the list using a loop and a temporary pointer</li>
        </ul>
        <p>The resulting structure is: <code>node1(10) -> node2(20) -> node3(30) -> nullptr</code></p>
    </div>

    <h3>Example 4: Basic Operations in LinkedList Class</h3>
    <pre class="code-block"><code><span class="code-keyword">class</span> LinkedList {
<span class="code-keyword">private</span>:
    Node* head;
    
<span class="code-keyword">public</span>:
    LinkedList() {
        head = nullptr;
    }
    
    <span class="code-comment">// Method to print all elements in the list</span>
    <span class="code-keyword">void</span> printList() {
        Node* current = head;
        cout << "List elements: ";
        <span class="code-keyword">while</span> (current != nullptr) {
            cout << current->data << " ";
            current = current->next;
        }
        cout << endl;
    }
    
    <span class="code-comment">// Method to count nodes in the list</span>
    <span class="code-keyword">int</span> countNodes() {
        <span class="code-keyword">int</span> count = 0;
        Node* current = head;
        <span class="code-keyword">while</span> (current != nullptr) {
            count++;
            current = current->next;
        }
        <span class="code-keyword">return</span> count;
    }
    
    <span class="code-comment">// Method to search for a value</span>
    <span class="code-keyword">bool</span> search(<span class="code-keyword">int</span> key) {
        Node* current = head;
        <span class="code-keyword">while</span> (current != nullptr) {
            <span class="code-keyword">if</span> (current->data == key) {
                <span class="code-keyword">return</span> true;  <span class="code-comment">// Found the key</span>
            }
            current = current->next;
        }
        <span class="code-keyword">return</span> false;  <span class="code-comment">// Key not found</span>
    }
};</code></pre>
    <div class="explanation">
        <p>These methods provide basic operations on a LinkedList:</p>
        <ul>
            <li><strong>printList()</strong>: Traverses the list and prints each element</li>
            <li><strong>countNodes()</strong>: Counts how many nodes are in the list</li>
            <li><strong>search()</strong>: Checks if a specific value exists in the list</li>
        </ul>
        <p>Each method uses a similar pattern of traversing the list from the head to the end using a temporary pointer.</p>
    </div>

    <h3>Example 5: Adding Nodes at Different Positions</h3>
    <pre class="code-block"><code><span class="code-comment">// Add methods to the LinkedList class</span>

<span class="code-comment">// Method to add a node at the beginning (head)</span>
<span class="code-keyword">void</span> addFirst(<span class="code-keyword">int</span> value) {
    Node* newNode = <span class="code-keyword">new</span> Node(value);
    newNode->next = head;  <span class="code-comment">// Point new node to current head</span>
    head = newNode;        <span class="code-comment">// Update head to be the new node</span>
}

<span class="code-comment">// Method to add a node at the end</span>
<span class="code-keyword">void</span> addLast(<span class="code-keyword">int</span> value) {
    Node* newNode = <span class="code-keyword">new</span> Node(value);
    
    <span class="code-comment">// If list is empty, make new node the head</span>
    <span class="code-keyword">if</span> (head == nullptr) {
        head = newNode;
        <span class="code-keyword">return</span>;
    }
    
    <span class="code-comment">// Otherwise, find the last node</span>
    Node* last = head;
    <span class="code-keyword">while</span> (last->next != nullptr) {
        last = last->next;
    }
    
    <span class="code-comment">// Link the last node to the new node</span>
    last->next = newNode;
}

<span class="code-comment">// Method to add a node after a specified position</span>
<span class="code-keyword">void</span> addAfterPosition(<span class="code-keyword">int</span> position, <span class="code-keyword">int</span> value) {
    <span class="code-comment">// If position is 0, add at the beginning</span>
    <span class="code-keyword">if</span> (position == 0) {
        addFirst(value);
        <span class="code-keyword">return</span>;
    }
    
    Node* newNode = <span class="code-keyword">new</span> Node(value);
    Node* current = head;
    <span class="code-keyword">int</span> count = 0;
    
    <span class="code-comment">// Find the position</span>
    <span class="code-keyword">while</span> (current != nullptr && count < position) {
        count++;
        current = current->next;
    }
    
    <span class="code-comment">// If position is out of bounds</span>
    <span class="code-keyword">if</span> (current == nullptr) {
        cout << "Position out of bounds" << endl;
        <span class="code-keyword">delete</span> newNode;  <span class="code-comment">// Clean up the unused node</span>
        <span class="code-keyword">return</span>;
    }
    
    <span class="code-comment">// Insert the new node</span>
    newNode->next = current->next;
    current->next = newNode;
}</code></pre>
    <div class="explanation">
        <p>These methods allow adding nodes at different positions:</p>
        <ul>
            <li><strong>addFirst()</strong>: Adds a new node at the beginning (as the new head)</li>
            <li><strong>addLast()</strong>: Adds a new node at the end of the list</li>
            <li><strong>addAfterPosition()</strong>: Adds a new node after a specified position (0-indexed)</li>
        </ul>
        <p>Each method handles special cases such as empty lists or invalid positions.</p>
    </div>

    <h3>Example 6: Deleting Nodes from Different Positions</h3>
    <pre class="code-block"><code><span class="code-comment">// Add more methods to the LinkedList class</span>

<span class="code-comment">// Method to delete the first node</span>
<span class="code-keyword">void</span> deleteFirst() {
    <span class="code-comment">// Check if list is empty</span>
    <span class="code-keyword">if</span> (head == nullptr) {
        cout << "List is empty, nothing to delete" << endl;
        <span class="code-keyword">return</span>;
    }
    
    Node* temp = head;      <span class="code-comment">// Store current head</span>
    head = head->next;      <span class="code-comment">// Move head to next node</span>
    <span class="code-keyword">delete</span> temp;          <span class="code-comment">// Free the memory of old head</span>
}

<span class="code-comment">// Method to delete the last node</span>
<span class="code-keyword">void</span> deleteLast() {
    <span class="code-comment">// Check if list is empty</span>
    <span class="code-keyword">if</span> (head == nullptr) {
        cout << "List is empty, nothing to delete" << endl;
        <span class="code-keyword">return</span>;
    }
    
    <span class="code-comment">// If there's only one node</span>
    <span class="code-keyword">if</span> (head->next == nullptr) {
        <span class="code-keyword">delete</span> head;
        head = nullptr;
        <span class="code-keyword">return</span>;
    }
    
    <span class="code-comment">// Find the second-to-last node</span>
    Node* current = head;
    <span class="code-keyword">while</span> (current->next->next != nullptr) {
        current = current->next;
    }
    
    <span class="code-comment">// Delete the last node and update second-to-last node's next pointer</span>
    <span class="code-keyword">delete</span> current->next;
    current->next = nullptr;
}

<span class="code-comment">// Method to delete a node at a specified position</span>
<span class="code-keyword">void</span> deleteAtPosition(<span class="code-keyword">int</span> position) {
    <span class="code-comment">// Check if list is empty</span>
    <span class="code-keyword">if</span> (head == nullptr) {
        cout << "List is empty, nothing to delete" << endl;
        <span class="code-keyword">return</span>;
    }
    
    <span class="code-comment">// If deleting the first node</span>
    <span class="code-keyword">if</span> (position == 0) {
        deleteFirst();
        <span class="code-keyword">return</span>;
    }
    
    <span class="code-comment">// Find the node before the one to be deleted</span>
    Node* current = head;
    <span class="code-keyword">int</span> count = 0;
    <span class="code-keyword">while</span> (current != nullptr && count < position - 1) {
        count++;
        current = current->next;
    }
    
    <span class="code-comment">// If position is out of bounds or next node is null</span>
    <span class="code-keyword">if</span> (current == nullptr || current->next == nullptr) {
        cout << "Position out of bounds" << endl;
        <span class="code-keyword">return</span>;
    }
    
    <span class="code-comment">// Delete the node at position</span>
    Node* temp = current->next;       <span class="code-comment">// Node to be deleted</span>
    current->next = current->next->next;  <span class="code-comment">// Skip over the node to be deleted</span>
    <span class="code-keyword">delete</span> temp;                    <span class="code-comment">// Free memory</span>
}</code></pre>
    <div class="explanation">
        <p>These methods handle deletion operations:</p>
        <ul>
            <li><strong>deleteFirst()</strong>: Removes the first node (head) of the list</li>
            <li><strong>deleteLast()</strong>: Removes the last node of the list</li>
            <li><strong>deleteAtPosition()</strong>: Removes a node at a specified position</li>
        </ul>
        <p>Each method includes error handling for empty lists and invalid positions, and properly manages memory deallocation.</p>
    </div>

    <h3>Example 7: Complete LinkedList Implementation and Usage</h3>
    <pre class="code-block"><code><span class="code-keyword">#include</span> <span class="code-string">&lt;iostream&gt;</span>
<span class="code-keyword">using namespace</span> std;

<span class="code-comment">// Node class definition</span>
<span class="code-keyword">class</span> Node {
<span class="code-keyword">public</span>:
    <span class="code-keyword">int</span> data;
    Node* next;
    
    Node(<span class="code-keyword">int</span> value) {
        data = value;
        next = nullptr;
    }
};

<span class="code-comment">// LinkedList class with all methods</span>
<span class="code-keyword">class</span> LinkedList {
<span class="code-keyword">private</span>:
    Node* head;
    
<span class="code-keyword">public</span>:
    LinkedList() {
        head = nullptr;
    }
    
    <span class="code-comment">// Destructor to free memory</span>
    ~LinkedList() {
        Node* current = head;
        <span class="code-keyword">while</span> (current != nullptr) {
            Node* temp = current;
            current = current->next;
            <span class="code-keyword">delete</span> temp;
        }
        head = nullptr;
    }
    
    <span class="code-comment">// All the methods defined earlier (printList, countNodes, search,
    // addFirst, addLast, addAfterPosition, deleteFirst, deleteLast, deleteAtPosition)</span>
    
    <span class="code-keyword">void</span> printList() {
        Node* current = head;
        cout << "List elements: ";
        <span class="code-keyword">while</span> (current != nullptr) {
            cout << current->data << " ";
            current = current->next;
        }
        cout << endl;
    }
    
    <span class="code-keyword">int</span> countNodes() {
        <span class="code-keyword">int</span> count = 0;
        Node* current = head;
        <span class="code-keyword">while</span> (current != nullptr) {
            count++;
            current = current->next;
        }
        <span class="code-keyword">return</span> count;
    }
    
    <span class="code-keyword">bool</span> search(<span class="code-keyword">int</span> key) {
        Node* current = head;
        <span class="code-keyword">while</span> (current != nullptr) {
            <span class="code-keyword">if</span> (current->data == key) {
                <span class="code-keyword">return</span> true;
            }
            current = current->next;
        }
        <span class="code-keyword">return</span> false;
    }
    
    <span class="code-keyword">void</span> addFirst(<span class="code-keyword">int</span> value) {
        Node* newNode = <span class="code-keyword">new</span> Node(value);
        newNode->next = head;
        head = newNode;
    }
    
    <span class="code-keyword">void</span> addLast(<span class="code-keyword">int</span> value) {
        Node* newNode = <span class="code-keyword">new</span> Node(value);
        
        <span class="code-keyword">if</span> (head == nullptr) {
            head = newNode;
            <span class="code-keyword">return</span>;
        }
        
        Node* last = head;
        <span class="code-keyword">while</span> (last->next != nullptr) {
            last = last->next;
        }
        
        last->next = newNode;
    }
    
    <span class="code-keyword">void</span> addAfterPosition(<span class="code-keyword">int</span> position, <span class="code-keyword">int</span> value) {
        <span class="code-keyword">if</span> (position == 0) {
            addFirst(value);
            <span class="code-keyword">return</span>;
        }
        
        Node* newNode = <span class="code-keyword">new</span> Node(value);
        Node* current = head;
        <span class="code-keyword">int</span> count = 0;
        
        <span class="code-keyword">while</span> (current != nullptr && count < position) {
            count++;
            current = current->next;
        }
        
        <span class="code-keyword">if</span> (current == nullptr) {
            cout << "Position out of bounds" << endl;
            <span class="code-keyword">delete</span> newNode;
            <span class="code-keyword">return</span>;
        }
        
        newNode->next = current->next;
        current->next = newNode;
    }
    
    <span class="code-keyword">void</span> deleteFirst() {
        <span class="code-keyword">if</span> (head == nullptr) {
            cout << "List is empty, nothing to delete" << endl;
            <span class="code-keyword">return</span>;
        }
        
        Node* temp = head;
        head = head->next;
        <span class="code-keyword">delete</span> temp;
    }
    
    <span class="code-keyword">void</span> deleteLast() {
        <span class="code-keyword">if</span> (head == nullptr) {
            cout << "List is empty, nothing to delete" << endl;
            <span class="code-keyword">return</span>;
        }
        
        <span class="code-keyword">if</span> (head->next == nullptr) {
            <span class="code-keyword">delete</span> head;
            head = nullptr;
            <span class="code-keyword">return</span>;
        }
        
        Node* current = head;
        <span class="code-keyword">while</span> (current->next->next != nullptr) {
            current = current->next;
        }
        
        <span class="code-keyword">delete</span> current->next;
        current->next = nullptr;
    }
    
    <span class="code-keyword">void</span> deleteAtPosition(<span class="code-keyword">int</span> position) {
        <span class="code-keyword">if</span> (head == nullptr) {
            cout << "List is empty, nothing to delete" << endl;
            <span class="code-keyword">return</span>;
        }
        
        <span class="code-keyword">if</span> (position == 0) {
            deleteFirst();
            <span class="code-keyword">return</span>;
        }
        
        Node* current = head;
        <span class="code-keyword">int</span> count = 0;
        <span class="code-keyword">while</span> (current != nullptr && count < position - 1) {
            count++;
            current = current->next;
        }
        
        <span class="code-keyword">if</span> (current == nullptr || current->next == nullptr) {
            cout << "Position out of bounds" << endl;
            <span class="code-keyword">return</span>;
        }
        
        Node* temp = current->next;
        current->next = current->next->next;
        <span class="code-keyword">delete</span> temp;
    }
};

<span class="code-keyword">int</span> main() {
    LinkedList list;
    
    <span class="code-comment">// Adding elements</span>
    list.addFirst(30);   <span class="code-comment">// List: 30</span>
    list.addFirst(20);   <span class="code-comment">// List: 20 -> 30</span>
    list.addFirst(10);   <span class="code-comment">// List: 10 -> 20 -> 30</span>
    list.addLast(40);    <span class="code-comment">// List: 10 -> 20 -> 30 -> 40</span>
    
    list.printList();    <span class="code-comment">// Output: List elements: 10 20 30 40</span>
    cout << "Number of nodes: " << list.countNodes() << endl;  <span class="code-comment">// Output: 4</span>
    
    <span class="code-comment">// Searching</span>
    cout << "Search for 20: " << (list.search(20) ? "Found" : "Not found") << endl;  <span class="code-comment">// Output: Found</span>
    cout << "Search for 50: " << (list.search(50) ? "Found" : "Not found") << endl;  <span class="code-comment">// Output: Not found</span>
    
    <span class="code-comment">// Adding at position</span>
    list.addAfterPosition(2, 25);  <span class="code-comment">// After node at index 2 (value 30)</span>
    list.printList();  <span class="code-comment">// Output: List elements: 10 20 30 25 40</span>
    
    <span class="code-comment">// Deletion operations</span>
    list.deleteFirst();
    list.printList();  <span class="code-comment">// Output: List elements: 20 30 25 40</span>
    
    list.deleteLast();
    list.printList();  <span class="code-comment">// Output: List elements: 20 30 25</span>
    
    list.deleteAtPosition(1);  <span class="code-comment">// Delete node at index 1 (value 30)</span>
    list.printList();  <span class="code-comment">// Output: List elements: 20 25</span>
    
    <span class="code-keyword">return</span> 0;
}</code></pre>
    <div class="explanation">
        <p>This comprehensive example includes:</p>
        <ul>
            <li>A complete <code>Node</code> class definition</li>
            <li>A complete <code>LinkedList</code> class with all operations</li>
            <li>A destructor to properly free memory when the list is destroyed</li>
            <li>A <code>main()</code> function demonstrating the usage of all LinkedList operations</li>
        </ul>
        <p>The program demonstrates adding nodes at different positions, searching for values, counting nodes, and deleting nodes from different positions.</p>
    </div>

    <h3>Advantages and Disadvantages of LinkedList</h3>
    <div class="comparison">
        <div class="advantages">
            <h4>Advantages:</h4>
            <ul>
                <li><strong>Dynamic Size:</strong> Can grow or shrink at runtime</li>
                <li><strong>Efficient Insertions/Deletions:</strong> O(1) time complexity if position is known</li>
                <li><strong>Memory Efficiency:</strong> Only allocates memory as needed</li>
                <li><strong>No Reallocation:</strong> Unlike arrays, doesn't require shifting elements or reallocating memory</li>
            </ul>
        </div>
        <div class="disadvantages">
            <h4>Disadvantages:</h4>
            <ul>
                <li><strong>Random Access:</strong> O(n) time to access arbitrary elements (no direct indexing)</li>
                <li><strong>Extra Memory:</strong> Requires additional memory for storing pointers</li>
                <li><strong>Traversal:</strong> Must start from the head and follow the chain of pointers</li>
            </ul>
        </div>
    </div>
</section>
</body>
</html>