<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP in C#</title>
    <link rel="stylesheet" href="styles.css">
    <style>
ul {
    list-style-type: disc;         /* Bullet type */
    padding-left: 20px;            /* Indent */
    margin: 10px 0;                /* Vertical spacing */
    font-family: Arial, sans-serif;
    font-size: 16px;
    color: #333;
}

ul li {
    padding: 6px 0;                /* Space between items */
    transition: background-color 0.3s;
}

ul li:hover {
    background-color: #f0f0f0;     /* Light hover effect */
    cursor: pointer;
}
</style>

</head>

<body>
   <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-logo">
            <img src="logo.png" alt="Page Logo" class="logo">
        </div>
        <ul class="nav-list">
            <li><a href="#data-structures">Data Structures</a></li>
            <li><a href="#linear">Linear Data Structures</a></li>
            <li><a href="#non-linear">Non-Linear Data Structures</a></li>
            <li><a href="#pointers">Pointers</a></li>
            <li><a href="#pointer-arrays">Pointers & Arrays</a></li>
            <li><a href="#classes">Classes & Objects</a></li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main class="container">
        <!-- Data Structures -->
        <section id="data-structures" class="section">
            <h2>Data Structures</h2>
            <div class="definition">
                <p class="english-def"><strong>Definition:</strong> A <span class="keyword">Data Structure</span> is a way of organizing, storing, and managing data efficiently for access and modification.</p>
                <p class="arabic-def"><strong>Ø§Ù„ØªØ¹Ø±ÙŠÙ:</strong> <span class="keyword">Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</span> Ù‡Ùˆ Ø·Ø±ÙŠÙ‚Ø© Ù„ØªÙ†Ø¸ÙŠÙ… ÙˆØªØ®Ø²ÙŠÙ† ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨ÙƒÙØ§Ø¡Ø© Ù„Ù„ÙˆØµÙˆÙ„ ÙˆØ§Ù„ØªØ¹Ø¯ÙŠÙ„.</p>
            </div>
        </section>

        <!-- Linear Data Structures -->
        <section id="linear" class="section">
            <h2>Linear Data Structures</h2>
            <div class="definition"><p class="english-def"><strong>Definition:</strong> In <span class="keyword">Linear Data Structures</span>, elements are arranged sequentially, one after another.</p>
                <p class="arabic-def"><strong>Ø§Ù„ØªØ¹Ø±ÙŠÙ:</strong> ÙÙŠ <span class="keyword">Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø®Ø·ÙŠØ©</span>ØŒ ÙŠØªÙ… ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø¨Ø§Ù„ØªØ³Ù„Ø³Ù„ØŒ ÙˆØ§Ø­Ø¯Ù‹Ø§ ØªÙ„Ùˆ Ø§Ù„Ø¢Ø®Ø±.</p>
            </div>
            <ul style="list-style-type: none; padding-left: 20px; color: #333; font-size: 16px; line-height: 1.6;">
                <li class="explanation" style="margin-bottom: 10px; width: 50%;">Array<span style="padding-left: 50%;">Linked List</span></li>
                <li class="explanation" style="margin-bottom: 10px; width: 50%;">Stack<span style="padding-left: 50%;">Queue</span></li>
            </ul>
        </section>

        <!-- Non-Linear Data Structures -->
        <section id="non-linear" class="section">
            <h2>Non-Linear Data Structures</h2>
            <div class="definition">
                <p class="english-def"><strong>Definition:</strong> In <span class="keyword">Non-Linear Data Structures</span>, elements are not arranged sequentially. They represent hierarchical or networked relationships.</p>
                <p class="arabic-def"><strong>Ø§Ù„ØªØ¹Ø±ÙŠÙ:</strong> ÙÙŠ <span class="keyword">Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ø§Ù„Ø®Ø·ÙŠØ©</span>ØŒ Ù„Ø§ ÙŠØªÙ… ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø¨Ø§Ù„ØªØ³Ù„Ø³Ù„. ØºØ§Ù„Ø¨Ù‹Ø§ Ù…Ø§ ØªÙ…Ø«Ù„ Ø¹Ù„Ø§Ù‚Ø§Øª Ù‡Ø±Ù…ÙŠØ© Ø£Ùˆ Ø´Ø¨ÙƒÙŠØ©.</p>
            </div>
            <ul style="list-style-type: none; padding-left: 20px; color: #444; font-size: 16px; line-height: 1.6;">
                <li class="explanation" style="margin-bottom: 10px; width: 50%;">Tree <span style="padding-left: 50%;">Graph</span></li>
            </ul>
        </section>

        <!-- Pointers -->
        <section id="pointers" class="section">
            <h2>Pointers in C++</h2>
            <div class="definition">
                <p class="english-def"><strong>Definition:</strong> A <span class="keyword">pointer</span> stores the memory address of another variable.</p>
                <p class="arabic-def"><strong>Ø§Ù„ØªØ¹Ø±ÙŠÙ:</strong> <span class="keyword">Ø§Ù„Ù…Ø¤Ø´Ø±</span> Ù‡Ùˆ Ù…ØªØºÙŠØ± ÙŠØ®Ø²Ù† Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù„Ù…ØªØºÙŠØ± Ø¢Ø®Ø±.</p>
            </div>

            <div class="explanation">
                <p>Pointers are special variables that store memory addresses rather than values. They allow direct manipulation of memory, dynamic memory allocation, and efficient passing of large data structures.</p>
            </div>

            <h3>Example 1: Basic Pointer</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> a = 42;
<span class="code-keyword">int</span>* p = &a;
cout << *p; <span class="code-comment">// Outputs 42</span></code></pre>
            <div class="explanation">
                <p>This example shows how to declare a pointer, assign it the address of a variable, and access the value using dereferencing.</p>
            </div>

            <h3>Example 2: Uninitialized Pointer (Runtime Error)</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span>* q;
cout << *q; <span class="code-comment">// âŒ Undefined behavior</span></code></pre>
            <div class="explanation">
                <p>Dereferencing an uninitialized pointer leads to undefined behavior because it points to a garbage address in memory.</p>
            </div>

            <h3>Example 3: Dynamic Memory Allocation</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span>* dynamicInt = <span class="code-keyword">new int</span>;
*dynamicInt = 100;
cout << *dynamicInt; <span class="code-comment">// Outputs 100</span>

<span class="code-comment">// Don't forget to free memory when done</span>
<span class="code-keyword">delete</span> dynamicInt;
dynamicInt = nullptr; <span class="code-comment">// Good practice to avoid dangling pointers</span></code></pre>
            <div class="explanation">
                <p>Using <code>new</code> allocates memory dynamically. You must release it with <code>delete</code> to avoid memory leaks. Setting the pointer to <code>nullptr</code> helps prevent dangling pointer issues.</p>
            </div>

            <h3>ğŸ” Important Concepts</h3>
            <ul>
                <li><strong>Dangling Pointer:</strong> A pointer that still points to memory that has already been deallocated.</li>
                <li><strong>Memory Leak:</strong> When dynamically allocated memory is never released using <code>delete</code>.</li>
            </ul>
            <div class="explanation">
                <p>Always use <code>delete</code> after <code>new</code> and avoid accessing memory after deletion to prevent these issues.</p>
            </div>

            <h4>Example: Dangling Pointer (without null)</h4>
            <pre class="code-block"><code><span class="code-keyword">int</span> val = 25;
<span class="code-keyword">int</span>* ptr = &val; 
<span class="code-keyword">delete</span> ptr; <span class="code-comment">// âŒ Error: delete on non-dynamic memory (undefined behavior)</span> 
cout << *ptr; <span class="code-comment">// âŒ Dangling pointer â€” accessing invalid memory</span></code></pre>
            <div class="explanation">
                <p>This is incorrect usage: <code>val</code> is not dynamically allocated, so calling <code>delete ptr</code> is undefined behavior. After deletion, <code>ptr</code> becomes dangling and accessing it is dangerous.</p>
            </div>

            <h4>Example: Dangling Pointer (resolved with nullptr)</h4>
            <pre class="code-block"><code><span class="code-keyword">int</span> val = 25;
<span class="code-keyword">int</span>* ptr = &val; <span class="code-comment">// Not using delete here since memory is not dynamic</span>
ptr = <span class="code-keyword">nullptr</span>; <span class="code-comment">// Safe: pointer now points to nothing, avoids dangling</span></code></pre>
            <div class="explanation">
                <p>If you don't use <code>new</code>, you shouldn't call <code>delete</code>. But it's still good practice to set the pointer to <code>nullptr</code> when it's no longer needed.</p>
            </div>

            <h4>Example: Memory Leak</h4>
            <pre class="code-block"><code><span class="code-keyword">int</span> x = 77;
<span class="code-keyword">int</span>* leakedPtr = <span class="code-keyword">new int</span>;
*leakedPtr = x; 
cout << *leakedPtr; <span class="code-comment">// 77 is printed</span>
<span class="code-comment">// âŒ No delete â€” memory remains allocated (leak)</span></code></pre>
            <div class="explanation">
                <p>The variable <code>x</code> is used to assign a value to dynamically allocated memory. However, the memory is not deallocated using <code>delete</code>, resulting in a memory leak.</p>
            </div>

            <h4>Example: Pointer Assignments and Deletion</h4>
            <pre class="code-block"><code><span class="code-keyword">int</span>* p = <span class="code-keyword">new int</span>;
<span class="code-keyword">int</span>* q = <span class="code-keyword">new int</span>;
<span class="code-keyword">int</span>* r;

*p = 17;
r = q;
*q = 42;
p = q;
<span class="code-keyword">delete</span> r; <span class="code-comment">// Deletes memory pointed by q (also r and p now)</span></code></pre>
            <div class="explanation">
                <p>This example demonstrates how multiple pointers can reference the same dynamically allocated memory. After assigning <code>r = q</code> and <code>p = q</code>, all three pointers refer to the same memory location. Deleting <code>r</code> also affects <code>q</code> and <code>p</code>, potentially making them dangling pointers if accessed afterwards.</p>
            </div>
        </section>

        <!-- Pointers and Arrays -->
        <section id="pointer-arrays" class="section">
            <h2>Pointers and Arrays</h2>
            <div class="definition">
                <p class="english-def"><strong>Definition:</strong> An array name behaves like a pointer to its first element.</p>
                <p class="arabic-def"><strong>Ø§Ù„ØªØ¹Ø±ÙŠÙ:</strong> ÙÙŠ ++CØŒ Ø§Ø³Ù… Ø§Ù„Ù…ØµÙÙˆÙØ© ÙŠØ¹Ù…Ù„ ÙƒÙ…Ø¤Ø´Ø± Ø¥Ù„Ù‰ Ø£ÙˆÙ„ Ø¹Ù†ØµØ± ÙÙŠÙ‡Ø§.</p>
            </div>

            <h3>Example 1: Pointer to Array</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> nums[] = {5, 10, 15};
<span class="code-keyword">int</span>* ptr = nums;
cout << *ptr;       <span class="code-comment">// 5</span>
cout << *(ptr + 1); <span class="code-comment">// 10</span></code></pre>
            <div class="explanation">
                <p>The pointer <code>ptr</code> points to the first element of the array. Pointer arithmetic lets you access other elements.</p>
            </div>

            <h3>Example 2: Pointer Arithmetic</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> arr[3] = {100, 200, 300};
<span class="code-keyword">int</span>* p = arr;
cout << *(p + 2); <span class="code-comment">// 300</span></code></pre>
            <div class="explanation">
                <p>Accessing <code>*(p + 2)</code> retrieves the third element in the array.</p>
            </div>

            <h3>Example 3: Array Traversal Using Pointers</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> numbers[] = {5, 15, 25, 35, 45};
<span class="code-keyword">int</span>* ptr = numbers;

<span class="code-comment">// Method 1: Using pointer arithmetic</span>
<span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = 0; i < 5; i++) {
    cout << *(ptr + i) << " "; <span class="code-comment">// 5 15 25 35 45</span>
}

<span class="code-comment">// Method 2: Incrementing the pointer</span>
ptr = numbers;
<span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = 0; i < 5; i++) {
    cout << *ptr << " ";
    ptr++;
}</code></pre>
            <div class="explanation">
                <p>Both techniques loop through the array using pointers: one by offset, the other by pointer increment.</p>
            </div>
        </section>

        <section class="section">
            <h2>Pointer Arithmetic - Valid and Invalid Operations</h2>

            <h3>Example 1: Valid Pointer Addition and Subtraction</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> arr[] = {10, 20, 30, 40};
<span class="code-keyword">int</span>* ptr = arr;

cout << *(ptr + 2); <span class="code-comment">// 30</span>
cout << *(ptr + 1) - *(ptr); <span class="code-comment">// 10 (20 - 10)</span></code></pre>
            <div class="explanation">
                <p>Pointer addition and subtraction are valid: they move the pointer forward or backward by element size.</p>
            </div>

            <h3>Example 2: Invalid Pointer Multiplication and Division</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span>* ptr;
<span class="code-comment">// ptr * 2;      âŒ Invalid â€” multiplication not allowed directly on pointer
// ptr / 2;      âŒ Invalid â€” division not allowed directly on pointer</span></code></pre>
            <div class="explanation">
                <p>Multiplying or dividing pointers is not allowed and results in a syntax or compile-time error.</p>
            </div>

            <h3>Example 3: *(ptr + 1), (*ptr + 1), and *(*ptr + 1)</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> arr[] = {5, 10, 15};
<span class="code-keyword">int</span>* ptr = arr;

cout << *(ptr + 1);     <span class="code-comment">// 10 â€” second element</span>
cout << (*ptr + 1);     <span class="code-comment">// 6  â€” 5 + 1</span>
<span class="code-comment">// cout << *(*ptr + 1); âŒ Error â€” *ptr is 5 â†’ 5 + 1 = 6 â†’ *(6) is invalid</span></code></pre>
            <div class="explanation">
                <p><code>*(ptr + 1)</code> accesses the next element, <code>(*ptr + 1)</code> adds 1 to the value pointed by ptr. <code>*(*ptr + 1)</code> is invalid because it tries to dereference a value as if it were an address.</p>
            </div>

            <h3>Example 4: Mixing * with - and /</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> arr[] = {10, 20, 30};
<span class="code-keyword">int</span>* ptr = arr;

cout << *(ptr + 2);     <span class="code-comment">// 30 â€” valid</span>
cout << *ptr - 2;       <span class="code-comment">// 8 â€” valid (10 - 2)</span>
<span class="code-comment">// cout << *ptr / ptr;  âŒ Invalid â€” can't divide by pointer</span></code></pre>
            <div class="explanation">
                <p>Using * with arithmetic on values is valid (e.g., subtracting from the dereferenced value), but dividing by a pointer itself is invalid.</p>
            </div>
        </section>

        <!-- Search Operations -->
        <section id="search-operations" class="section">
            <h2>Search Operations Using Pointers</h2>

            <h3>Example 1: Linear Search</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> arr[] = {1, 3, 5, 7, 9};
<span class="code-keyword">int</span>* p = arr;
<span class="code-keyword">int</span> key = 7;
<span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = 0; i < 5; i++) {
    <span class="code-keyword">if</span> (*(p + i) == key) {
        cout << "Found at index " << i;
    }
}</code></pre>
            <div class="explanation">
                <p>The loop compares each array element using pointer arithmetic. If found, it prints the index.</p>
            </div>

            <h3>Example 2: Search Not Found</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> arr[] = {2, 4, 6, 8};
<span class="code-keyword">int</span>* p = arr;
<span class="code-keyword">int</span> key = 10;
<span class="code-keyword">bool</span> found = false;
<span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = 0; i < 4; i++) {
    <span class="code-keyword">if</span> (*(p + i) == key) {
        found = true;
        <span class="code-keyword">break</span>;
    }
}
<span class="code-keyword">if</span> (!found) cout << "Not found";</code></pre>
            <div class="explanation">
                <p>This example searches for a value that doesn't exist. The <code>found</code> flag ensures proper reporting.</p>
            </div>
        </section>

        <!-- Classes and Objects -->
        <section id="classes" class="section">
            <h2>Classes and Objects in C++</h2>
            <div class="definition">
                <p class="english-def"><strong>Definition:</strong> A <span class="keyword">class</span> is a user-defined data type that encapsulates data and functions that operate on that data. An <span class="keyword">object</span> is an instance of a class.</p>
                <p class="arabic-def"><strong>Ø§Ù„ØªØ¹Ø±ÙŠÙ:</strong> <span class="keyword">Ø§Ù„ÙØ¦Ø©</span> Ù‡ÙŠ Ù†ÙˆØ¹ Ø¨ÙŠØ§Ù†Ø§Øª ÙŠØ¹Ø±ÙÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆÙŠØºÙ„Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„ØªÙŠ ØªØ¹Ù…Ù„ Ø¹Ù„Ù‰ ØªÙ„Ùƒ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. <span class="keyword">Ø§Ù„ÙƒØ§Ø¦Ù†</span> Ù‡Ùˆ Ù†Ù…ÙˆØ°Ø¬ Ù…Ù† Ø§Ù„ÙØ¦Ø©.</p>
            </div>

            <div class="explanation">
                <p>Classes are the foundation of object-oriented programming in C++. They combine data (attributes) and functions (methods) that operate on that data, helping to organize code and promote reusability.</p>
            </div>

            <h3>Example 1: Basic Class Definition</h3>
            <pre class="code-block"><code><span class="code-keyword">class</span> Student {
<span class="code-keyword">private</span>:
    <span class="code-keyword">int</span> id;
    <span class="code-keyword">string</span> name;
    <span class="code-keyword">float</span> gpa;

<span class="code-keyword">public</span>:
    <span class="code-comment">// Constructor</span>
    Student(<span class="code-keyword">int</span> _id, <span class="code-keyword">string</span> _name, <span class="code-keyword">float</span> _gpa) {
        id = _id;
        name = _name;
        gpa = _gpa;
    }

    <span class="code-comment">// Member function</span>
    <span class="code-keyword">void</span> displayInfo() {
        cout << "ID: " << id << endl;
        cout << "Name: " << name << endl;
        cout << "GPA: " << gpa << endl;
    }
};</code></pre>

            <h3>Example 2: Creating Objects</h3>
            <pre class="code-block"><code><span class="code-keyword">#include</span> <span class="code-string">&lt;iostream&gt;</span>
<span class="code-keyword">#include</span> <span class="code-string">&lt;string&gt;</span>
<span class="code-keyword">using namespace</span> std;

<span class="code-comment">// First define the Student class as above</span>

<span class="code-keyword">int</span> main() {
    <span class="code-comment">// Creating objects</span>
    Student s1(101, "John", 3.8);
    Student s2(102, "Sarah", 4.0);
    
    <span class="code-comment">// Calling member functions</span>
    cout << "Student 1 Information:" << endl;
    s1.displayInfo();
    
    cout << "Student 2 Information:" << endl;
    s2.displayInfo();
    
    <span class="code-keyword">return</span> 0;
}</code></pre>

            <h3>Example 3: Default Constructor and Setters/Getters</h3>
            <pre class="code-block"><code><span class="code-keyword">class</span> Rectangle {
<span class="code-keyword">private</span>:
    <span class="code-keyword">double</span> length;
    <span class="code-keyword">double</span> width;

<span class="code-keyword">public</span>:
    <span class="code-comment">// Default constructor</span>
    Rectangle() {
        length = 0.0;
        width = 0.0;
    }
    
    <span class="code-comment">// Parameterized constructor</span>
    Rectangle(<span class="code-keyword">double</span> l, <span class="code-keyword">double</span> w) {
        length = l;
        width = w;
    }
    
    <span class="code-comment">// Setter methods</span>
    <span class="code-keyword">void</span> setLength(<span class="code-keyword">double</span> l) {
        length = l;
    }
    
    <span class="code-keyword">void</span> setWidth(<span class="code-keyword">double</span> w) {
        width = w;
    }
    
    <span class="code-comment">// Getter methods</span>
    <span class="code-keyword">double</span> getLength() {
        <span class="code-keyword">return</span> length;
    }
    
    <span class="code-keyword">double</span> getWidth() {
        <span class="code-keyword">return</span> width;
    }
    
    <span class="code-comment">// Calculate area</span>
    <span class="code-keyword">double</span> getArea() {
        <span class="code-keyword">return</span> length * width;
    }
};</code></pre>

            <h3>Example 4: Using Objects of Rectangle Class</h3>
            <pre class="code-block"><code><span class="code-keyword">int</span> main() {
    <span class="code-comment">// Creating objects with different constructors</span>
    Rectangle rect1;              <span class="code-comment">// Using default constructor</span>
    Rectangle rect2(5.0, 3.0);    <span class="code-comment">// Using parameterized constructor</span>
    
    <span class="code-comment">// Using setter methods</span>
    rect1.setLength(4.0);
    rect1.setWidth(2.0);
    
    <span class="code-comment">// Display information</span>
    cout << "Rectangle 1:" << endl;
    cout << "Length: " << rect1.getLength() << endl;
    cout << "Width: " << rect1.getWidth() << endl;
    cout << "Area: " << rect1.getArea() << endl;  <span class="code-comment">// Outputs: Area: 8.0</span>
    
    cout << "Rectangle 2:" << endl;
    cout << "Length: " << rect2.getLength() << endl;
    cout << "Width: " << rect2.getWidth() << endl;
    cout << "Area: " << rect2.getArea() << endl;  <span class="code-comment">// Outputs: Area: 15.0</span>
    
    <span class="code-keyword">return</span> 0;
}</code></pre>
        </section>
    </main>
</body>
</html>
